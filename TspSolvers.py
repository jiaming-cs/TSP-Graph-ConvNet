from os import F_OK
import numpy as np
from utils.plot_utils import tour_nodes_to_tour_len



class TspSolvers:
    def __init__(self):
        return None

    def __construct_heuristic(self, probs, distances, prob_weight):
        assert(prob_weight <= 1)
        
        distance_weight = 1 - prob_weight
        distances /= np.max(distances, axis=1).reshape((-1, 1)) # map each row to (0, 1)
        distances_reward = np.ones(distances.shape) - distances # shoter distance has more reward
        for i in range(distances_reward.shape[0]):
            distances_reward[i][i] = float("-inf") # set it self negtive reward
        heuristic = probs * prob_weight + distances_reward * distance_weight
        
        return heuristic
        
    def greedy_search(self, probs, distances = None, prob_weight = None):
        '''
        Basic Gready Search
        probs: Probabiliity matrix generated by network
        distance: Distance matrix 
        prob_weight: the weight of probability on caclulating reward for 
        '''
        try:
            if distances is not None and prob_weight is not None:
                heuristic = self.__construct_heuristic(probs, distances, prob_weight)
            else:
                heuristic = probs   
            
            problem_size = heuristic.shape[0]
            greedy_solution = [0]
            while len(greedy_solution) != problem_size:
                for i in np.argsort(-heuristic[greedy_solution[-1]]):
                    if i not in greedy_solution:
                        greedy_solution.append(i)
                        break
            
            y_edges = np.zeros(probs.shape)
            
            for i in range(problem_size):
                y_edges[greedy_solution[i]][greedy_solution[(i+1)%problem_size]] = 1

            return greedy_solution, y_edges, True
        except:
            return None, None, False
    
    
    def __get_step_with_best_furture_rewards(self, heuristic, start_node, left_nodes, branch_size, decay=0.8):
        first_step = []
        rewards = np.zeros((branch_size, ))
        while len(first_step) != branch_size:
            for i in np.argsort(-heuristic[start_node]):
                if i in left_nodes:
                    first_step.append(i)
                    rewards[len(first_step)-1] += heuristic[start_node][i]
                if len(first_step) == branch_size:
                    break
        
        
        for index, i in enumerate(first_step):
            for j in np.argsort(-heuristic[i]):
                if j != start_node and j != i and j in left_nodes:
                    rewards[index] += heuristic[i][j] * decay
                    break
                    
        return first_step[np.argmax(rewards)]
                    
            
        
    
    def future_reward(self, probs, branch_size=3,  distances = None, prob_weight = None, decay=0.8):
        '''
        Basic Gready Search
        probs: Probabiliity matrix generated by network
        distance: Distance matrix 
        prob_weight: the weight of probability on caclulating reward for 
        '''
        try:
            if distances is not None and prob_weight is not None:
                heuristic = self.__construct_heuristic(probs, distances, prob_weight)
            else:
                heuristic = probs   
            
            problem_size = heuristic.shape[0]
            greedy_solution = [0]
            left_nodes = set(range(problem_size))
            left_nodes.remove(0)
            while len(greedy_solution) != problem_size:
                start_node = greedy_solution[-1]
                if len(left_nodes) > 2:
                    next_step = self.__get_step_with_best_furture_rewards(heuristic, start_node, left_nodes, branch_size, decay)
                else:
                    for i in np.argsort(-heuristic[greedy_solution[-1]]):
                        if i in left_nodes:
                            next_step = i
                            break
                left_nodes.remove(next_step)
                greedy_solution.append(next_step)
                
            y_edges = np.zeros(probs.shape)
            
            for i in range(problem_size):
                y_edges[greedy_solution[i]][greedy_solution[(i+1)%problem_size]] = 1

            return greedy_solution, y_edges, True
        except:
            return None, None, False
        
    
    def random_selection(self, probs):
        confused_nodes= self.get_confused_nodes(probs)
        problem_size = probs.shape[0]
        greedy_solution = [0]
        while len(greedy_solution) != problem_size:
            
                for i in np.argsort(-probs[greedy_solution[-1]]):
                    if i not in greedy_solution:
                        if greedy_solution[-1] in confused_nodes and np.random.random()>probs[greedy_solution[-1]][i]:
                            continue
                        greedy_solution.append(i)
                        break

        y_edges = np.zeros(probs.shape)
        
        for i in range(problem_size):
            y_edges[greedy_solution[i]][greedy_solution[(i+1)%problem_size]] = 1

        return greedy_solution, y_edges
    
    
    def dp_solver(self, probs, distances, threshold=0.3):
        def transfer(sets):
            su = 0
            for s in sets:
                su = su + 2**s
            return su
        
        
        def solve(node, future_sets):

            if len(future_sets) == 0:
                return distances[node][start_node]
            d = 99999
            distance = []
            for i, next_node in enumerate(future_sets):
                if probs_bin[node][next_node] == 0:
                    continue            
                distance.append(distances[node][next_node] + solve(next_node, future_sets[:next_node] + future_sets[next_node+1:]))
            min_d = min(distance)

            next_node = future_sets[distance.index(d)]

            c = transfer(future_sets)

            dp[node][c] = next_node
            return min_d
        
        probs_bin = np.where(probs>threshold, 1, 0)
        start_node = 0
        num = probs.shape[0]
        cities = list(range(num))
        past_sets = [start_node] 
        cities.pop(cities.index(start_node)) 
        dp = np.zeros((num, 2**num))
        
        solve(0, cities)
        
        nodes = list(range(num))
        ret = [0]
        while len(nodes) > 0:
            nodes.pop(nodes.index(start_node))
            m = transfer(nodes)
            next_node = dp[start_node][m]
            ret.append(next_node)
            start_node = next_node
            
        y_edges = np.zeros(probs.shape)
        
        for i in range(num):
            y_edges[ret[i]][ret[(i+1)%num]] = 1

        return ret, y_edges
    
    def brach_pruning(self, m, threshold, branch_limit=None):
        m_arg = np.argsort(m, axis=1)
        
        nodes_list = []
        for i, args in enumerate(m_arg):
            adj_nodes = [args[-1]]
            for j, arg in enumerate(list(reversed(args))[1:]):
                if branch_limit and j+1>=branch_limit:
                    break
                if m[i, arg] > threshold:
                    adj_nodes.append(arg)
                
            nodes_list.append(adj_nodes)
        count = 0
        start = 0
        while count < len(nodes_list):
            to = nodes_list[start][0]
            if start in nodes_list[to]:
                nodes_list[to].remove(start)
                start = to
            count += 1

        return nodes_list

    def __avg_dgree(self, nodes_list):
        total = 0
        for nodes in nodes_list:
            total += len(nodes)
        return total / len(nodes_list)
    
        
    def exclusive_search(self, probs, distances, threshold=0.3, branch_limit=3):
        def find_comb(cur, visited, comb_num=100):
            if len(comb)>=comb_num:
                return
            if len(cur) == nodes_num:
                comb.append(cur)
                return 
            start_node = cur[-1]
            for next_node in nodes_list[start_node]:
                if next_node not in visited:
                    v_copy = visited.copy()
                    v_copy.add(next_node)
                    find_comb(cur + [next_node], v_copy)  
        try:
            nodes_list = self.brach_pruning(probs, threshold, branch_limit)
            
            nodes_num = probs.shape[0]
            comb = []
            find_comb([0], {0})

        
            tour_lengths = [tour_nodes_to_tour_len(nodes, distances) for nodes in comb]
            
            min_tour = comb[np.argmin(tour_lengths)]                
            y_edges = np.zeros(probs.shape)
            
            for i in range(nodes_num):
                y_edges[min_tour[i]][min_tour[(i+1)%nodes_num]] = 1

            return min_tour, y_edges, True
        except:
            return None, None, False
    

    
    
    
    